"""LangGraph integration for Deep Agent workflow orchestration.

This module provides the LangGraph workflow definition for coordinating
specialized subagents in infrastructure automation tasks.
"""

import logging
from datetime import datetime, timezone
from typing import Annotated, Any, Dict, List, Literal, TypedDict

from langgraph.graph import END, StateGraph
from langgraph.graph.message import add_messages

from .memory_bus import AccessContext, MemoryBus

logger = logging.getLogger(__name__)


class AgentState(TypedDict):
    """State for the Deep Agent workflow.

    Attributes:
        messages: List of conversation messages
        task_type: Type of infrastructure task
        project_identifier: Harness project identifier
        context: Additional task context
        subagent_results: Results from subagent executions
        next_action: Next action to take in workflow
        supervisor_path: Ordered supervisors that handled routing
        routing_trace: Routing decisions for multi-level supervisors
        memory_bus: Shared memory bus for workflow data
        reflection_outcomes: Assessment of subagent outputs
        remediation_tasks: Follow-up tasks generated by reflection
        failure_history: Timeline of failed/at-risk subagent outcomes
        context_signals: Orchestration context signals for prompt adaptation
    """

    messages: Annotated[List[Dict[str, Any]], add_messages]
    task_type: str
    project_identifier: str
    context: Dict[str, Any]
    subagent_results: Dict[str, Any]
    next_action: str
    supervisor_path: List[str]
    routing_trace: List[Dict[str, str]]
    memory_bus: MemoryBus
    reflection_outcomes: Dict[str, Any]
    remediation_tasks: List[Dict[str, Any]]
    failure_history: List[Dict[str, Any]]
    context_signals: Dict[str, Any]


def _utc_timestamp() -> str:
    """Return an ISO-8601 UTC timestamp."""
    return datetime.now(timezone.utc).isoformat()


def _aggregate_risk_tags(reflection_outcomes: Dict[str, Any]) -> List[str]:
    """Collect unique risk tags from reflection outcomes."""
    tags: List[str] = []
    for outcome in reflection_outcomes.values():
        for risk in outcome.get("risks", []):
            if risk not in tags:
                tags.append(risk)
    return tags


def get_memory_bus(state: AgentState) -> MemoryBus:
    """Get or initialize the shared memory bus in workflow state."""
    memory_bus = state.get("memory_bus")
    if isinstance(memory_bus, MemoryBus):
        return memory_bus
    memory_bus = MemoryBus()
    state["memory_bus"] = memory_bus
    return memory_bus


def record_supervisor_decision(state: AgentState, supervisor: str, decision: str) -> None:
    """Record a routing decision for multi-level supervisors."""
    state.setdefault("supervisor_path", [])
    state.setdefault("routing_trace", [])
    state["supervisor_path"].append(supervisor)
    state["routing_trace"].append({"supervisor": supervisor, "decision": decision})


def root_supervisor_node(state: AgentState) -> AgentState:
    """Analyze the incoming task and determine top-level routing.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    task_type = state["task_type"]
    logger.info("Root supervisor analyzing task type: %s", task_type)

    if task_type in ["terraform", "iac", "infrastructure", "docker", "container", "dockerfile"]:
        state["next_action"] = "infra_supervisor"
    elif task_type in ["repository", "pipeline", "deployment"]:
        state["next_action"] = "delivery_supervisor"
    else:
        state["next_action"] = "general_orchestration"

    record_supervisor_decision(state, "root_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.root_supervisor",
        {"task_type": task_type, "next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("root_supervisor"),
    )
    logger.info("Root supervisor routing to: %s", state["next_action"])
    return state


def infra_supervisor_node(state: AgentState) -> AgentState:
    """Route infrastructure tasks to the correct infra subagent.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    task_type = state["task_type"]
    logger.info("Infra supervisor analyzing task type: %s", task_type)

    if task_type in ["terraform", "iac", "infrastructure"]:
        state["next_action"] = "iac_architect"
    elif task_type in ["docker", "container", "dockerfile"]:
        state["next_action"] = "container_workflow"
    else:
        state["next_action"] = "end"

    record_supervisor_decision(state, "infra_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.infra_supervisor",
        {"task_type": task_type, "next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("infra_supervisor"),
    )
    logger.info("Infra supervisor routing to: %s", state["next_action"])
    return state


def iac_architect_node(state: AgentState) -> AgentState:
    """Execute infrastructure-as-code tasks.

    Delegates to iac-golden-architect subagent for Terraform operations.

    Args:
        state: Current agent state

    Returns:
        Updated state with IaC results
    """
    logger.info("Executing iac-golden-architect subagent")

    # Placeholder for actual IaC operations
    result = {
        "subagent": "iac-golden-architect",
        "action": "terraform_plan",
        "status": "success",
        "output": "Infrastructure plan generated successfully",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["iac"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "iac.result",
        result,
        access_context=AccessContext.for_agent("iac_architect"),
    )
    return state


def container_workflow_node(state: AgentState) -> AgentState:
    """Execute container-related tasks.

    Delegates to container-workflow subagent for Docker operations.

    Args:
        state: Current agent state

    Returns:
        Updated state with container results
    """
    logger.info("Executing container-workflow subagent")

    # Placeholder for actual container operations
    result = {
        "subagent": "container-workflow",
        "action": "dockerfile_review",
        "status": "success",
        "output": "Dockerfile validated and optimized",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["container"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "container.result",
        result,
        access_context=AccessContext.for_agent("container_workflow"),
    )
    return state


def team_accelerator_node(state: AgentState) -> AgentState:
    """Execute team acceleration tasks.

    Delegates to team-accelerator subagent for repository and pipeline setup.

    Args:
        state: Current agent state

    Returns:
        Updated state with team accelerator results
    """
    logger.info("Executing team-accelerator subagent")

    # Placeholder for actual team acceleration operations
    result = {
        "subagent": "team-accelerator",
        "action": "repository_creation",
        "status": "success",
        "output": "Repository and pipeline configured",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["team"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "team.result",
        result,
        access_context=AccessContext.for_agent("team_accelerator"),
    )
    return state


def general_orchestration_node(state: AgentState) -> AgentState:
    """Handle general orchestration tasks.

    Coordinates multiple subagents for complex workflows.

    Args:
        state: Current agent state

    Returns:
        Updated state with orchestration results
    """
    logger.info("Executing general orchestration")

    result = {
        "subagent": "orchestrator",
        "action": "multi_agent_coordination",
        "status": "success",
        "output": "Task coordinated across subagents",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["orchestration"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "orchestration.result",
        result,
        access_context=AccessContext.for_workflow("general_orchestration"),
    )
    return state


def _evaluate_subagent_result(result: Dict[str, Any]) -> Dict[str, Any]:
    """Evaluate a subagent result for quality, completeness, and risks."""
    status = result.get("status", "unknown")
    output = result.get("output", "")
    risks: List[str] = []
    quality = "high"
    completeness = "complete"

    if status != "success":
        quality = "low"
        completeness = "partial"
        risks.append("execution_failed")

    if not output:
        completeness = "partial"
        risks.append("missing_output")

    if isinstance(output, str) and "warning" in output.lower():
        risks.append("warnings_present")

    return {"quality": quality, "completeness": completeness, "risks": risks}


def _supervisor_for_result(result_key: str, result: Dict[str, Any]) -> str:
    """Return the supervisor name to re-route for a given result."""
    mapping = {
        "iac": "infra_supervisor",
        "container": "infra_supervisor",
        "team": "delivery_supervisor",
        "orchestration": "root_supervisor",
    }
    return mapping.get(result_key, "root_supervisor")


def reflection_node(state: AgentState) -> AgentState:
    """Evaluate subagent results and determine remediation or rerouting."""
    logger.info("Reflecting on subagent results for quality checks")
    results = state.get("subagent_results", {})
    reflection_outcomes: Dict[str, Any] = {}
    remediation_tasks: List[Dict[str, Any]] = []
    reroute_targets: List[str] = []

    for result_key, result in results.items():
        outcome = _evaluate_subagent_result(result)
        reflection_outcomes[result_key] = outcome
        if outcome["risks"] or outcome["quality"] != "high" or outcome["completeness"] != "complete":
            remediation_tasks.append(
                {
                    "subagent": result.get("subagent", result_key),
                    "issue": outcome,
                    "action": "review_and_retry",
                }
            )
            reroute_targets.append(_supervisor_for_result(result_key, result))
            state.setdefault("failure_history", [])
            state["failure_history"].append(
                {
                    "timestamp": _utc_timestamp(),
                    "result_key": result_key,
                    "subagent": result.get("subagent", result_key),
                    "issue": outcome,
                }
            )

    state["reflection_outcomes"] = reflection_outcomes
    if remediation_tasks:
        state.setdefault("remediation_tasks", [])
        state["remediation_tasks"].extend(remediation_tasks)
    context_signals = state.setdefault("context_signals", {})
    risk_tags = _aggregate_risk_tags(reflection_outcomes)
    context_signals.update(
        {
            "needs_retry": bool(remediation_tasks),
            "risk_tags": risk_tags,
            "recent_failure_count": len(state.get("failure_history", [])),
            "last_failure_subagents": [
                entry["subagent"] for entry in state.get("failure_history", [])[-3:]
            ],
        }
    )

    state["next_action"] = reroute_targets[0] if reroute_targets else "complete"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "reflection.outcomes",
        {"outcomes": reflection_outcomes, "remediation_tasks": remediation_tasks},
        access_context=AccessContext.for_workflow("reflection"),
    )
    memory_bus.set(
        "workflow",
        "reflection.context_signals",
        context_signals,
        access_context=AccessContext.for_workflow("reflection"),
    )
    logger.info("Reflection completed; next action: %s", state["next_action"])
    return state


def delivery_supervisor_node(state: AgentState) -> AgentState:
    """Route delivery tasks to the delivery subagent.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    state["next_action"] = "team_accelerator"
    record_supervisor_decision(state, "delivery_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.delivery_supervisor",
        {"next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("delivery_supervisor"),
    )
    logger.info("Delivery supervisor routing to: %s", state["next_action"])
    return state


def route_root_step(
    state: AgentState,
) -> Literal["infra_supervisor", "delivery_supervisor", "general_orchestration", "end"]:
    """Route to the next workflow step based on state."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_infra_step(
    state: AgentState,
) -> Literal["iac_architect", "container_workflow", "end"]:
    """Route within the infra subgraph."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_delivery_step(
    state: AgentState,
) -> Literal["team_accelerator", "end"]:
    """Route within the delivery subgraph."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_post_subgraph(
    state: AgentState,
) -> Literal["reflection", "end"]:
    """Route after subgraph execution to reflection or end."""
    next_action = state.get("next_action", "end")
    if next_action == "reflection":
        return "reflection"
    return "end"


def route_to_end(state: AgentState) -> Literal["end"]:
    """Route leaf nodes to the end state."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return "end"


def route_reflection_step(
    state: AgentState,
) -> Literal["infra_supervisor", "delivery_supervisor", "root_supervisor", "end"]:
    """Route from reflection to the appropriate supervisor or end."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def create_infra_subgraph() -> StateGraph:
    """Create the infra supervisor subgraph."""
    infra_graph = StateGraph(AgentState)

    infra_graph.add_node("infra_supervisor", infra_supervisor_node)
    infra_graph.add_node("iac_architect", iac_architect_node)
    infra_graph.add_node("container_workflow", container_workflow_node)

    infra_graph.set_entry_point("infra_supervisor")
    infra_graph.add_conditional_edges(
        "infra_supervisor",
        route_infra_step,
        {
            "iac_architect": "iac_architect",
            "container_workflow": "container_workflow",
            "end": END,
        },
    )
    infra_graph.add_conditional_edges("iac_architect", route_to_end, {"end": END})
    infra_graph.add_conditional_edges("container_workflow", route_to_end, {"end": END})

    return infra_graph.compile()


def create_delivery_subgraph() -> StateGraph:
    """Create the delivery supervisor subgraph."""
    delivery_graph = StateGraph(AgentState)

    delivery_graph.add_node("delivery_supervisor", delivery_supervisor_node)
    delivery_graph.add_node("team_accelerator", team_accelerator_node)

    delivery_graph.set_entry_point("delivery_supervisor")
    delivery_graph.add_conditional_edges(
        "delivery_supervisor",
        route_delivery_step,
        {"team_accelerator": "team_accelerator", "end": END},
    )
    delivery_graph.add_conditional_edges("team_accelerator", route_to_end, {"end": END})

    return delivery_graph.compile()


def create_agent_workflow() -> StateGraph:
    """Create the LangGraph workflow for the Deep Agent.

    Returns:
        Compiled workflow graph
    """
    workflow = StateGraph(AgentState)

    # Add nodes
    workflow.add_node("root_supervisor", root_supervisor_node)
    workflow.add_node("infra_supervisor", create_infra_subgraph())
    workflow.add_node("delivery_supervisor", create_delivery_subgraph())
    workflow.add_node("general_orchestration", general_orchestration_node)
    workflow.add_node("reflection", reflection_node)

    # Define edges
    workflow.set_entry_point("root_supervisor")

    workflow.add_conditional_edges(
        "root_supervisor",
        route_root_step,
        {
            "infra_supervisor": "infra_supervisor",
            "delivery_supervisor": "delivery_supervisor",
            "general_orchestration": "general_orchestration",
            "end": END,
        },
    )

    workflow.add_conditional_edges(
        "infra_supervisor",
        route_post_subgraph,
        {"reflection": "reflection", "end": END},
    )
    workflow.add_conditional_edges(
        "delivery_supervisor",
        route_post_subgraph,
        {"reflection": "reflection", "end": END},
    )
    workflow.add_conditional_edges(
        "general_orchestration",
        route_post_subgraph,
        {"reflection": "reflection", "end": END},
    )
    workflow.add_conditional_edges(
        "reflection",
        route_reflection_step,
        {
            "infra_supervisor": "infra_supervisor",
            "delivery_supervisor": "delivery_supervisor",
            "root_supervisor": "root_supervisor",
            "end": END,
        },
    )

    return workflow.compile()
