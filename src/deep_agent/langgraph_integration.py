"""LangGraph integration for Deep Agent workflow orchestration.

This module provides the LangGraph workflow definition for coordinating
specialized subagents in infrastructure automation tasks.
"""

import copy
import logging
from datetime import datetime, timezone
from typing import Annotated, Any, Dict, List, Literal, TypedDict
from uuid import uuid4

from langgraph.checkpoint.base import create_checkpoint, empty_checkpoint
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import END, StateGraph
from langgraph.graph.message import add_messages

from .memory_bus import AccessContext, MemoryBus

logger = logging.getLogger(__name__)
CHECKPOINTER = MemorySaver()


class AgentState(TypedDict):
    """State for the Deep Agent workflow.

    Attributes:
        messages: List of conversation messages
        task_type: Type of infrastructure task
        project_identifier: Harness project identifier
        context: Additional task context
        subagent_results: Results from subagent executions
        next_action: Next action to take in workflow
        supervisor_path: Ordered supervisors that handled routing
        routing_trace: Routing decisions for multi-level supervisors
        memory_bus: Shared memory bus for workflow data
        reflection_outcomes: Assessment of subagent outputs
        remediation_tasks: Follow-up tasks generated by reflection
        failure_history: Timeline of failed/at-risk subagent outcomes
        context_signals: Orchestration context signals for prompt adaptation
    """

    messages: Annotated[List[Dict[str, Any]], add_messages]
    task_type: str
    project_identifier: str
    context: Dict[str, Any]
    subagent_results: Dict[str, Any]
    next_action: str
    supervisor_path: List[str]
    routing_trace: List[Dict[str, str]]
    memory_bus: MemoryBus
    reflection_outcomes: Dict[str, Any]
    remediation_tasks: List[Dict[str, Any]]
    candidate_results: List[Dict[str, Any]]
    fork_checkpoint_ids: List[str]
    merge_result: Dict[str, Any]


def get_memory_bus(state: AgentState) -> MemoryBus:
    """Get or initialize the shared memory bus in workflow state."""
    memory_bus = state.get("memory_bus")
    if isinstance(memory_bus, MemoryBus):
        return memory_bus
    memory_bus = MemoryBus()
    state["memory_bus"] = memory_bus
    return memory_bus


def record_supervisor_decision(state: AgentState, supervisor: str, decision: str) -> None:
    """Record a routing decision for multi-level supervisors."""
    state.setdefault("supervisor_path", [])
    state.setdefault("routing_trace", [])
    state["supervisor_path"].append(supervisor)
    state["routing_trace"].append({"supervisor": supervisor, "decision": decision})


def root_supervisor_node(state: AgentState) -> AgentState:
    """Analyze the incoming task and determine top-level routing.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    task_type = state["task_type"]
    logger.info("Root supervisor analyzing task type: %s", task_type)

    if task_type in ["terraform", "iac", "infrastructure", "docker", "container", "dockerfile"]:
        state["next_action"] = "infra_supervisor"
    elif task_type in ["repository", "pipeline", "deployment"]:
        state["next_action"] = "delivery_supervisor"
    else:
        state["next_action"] = "general_orchestration"

    record_supervisor_decision(state, "root_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.root_supervisor",
        {"task_type": task_type, "next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("root_supervisor"),
    )
    logger.info("Root supervisor routing to: %s", state["next_action"])
    return state


def infra_supervisor_node(state: AgentState) -> AgentState:
    """Route infrastructure tasks to the correct infra subagent.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    task_type = state["task_type"]
    logger.info("Infra supervisor analyzing task type: %s", task_type)

    if task_type in ["terraform", "iac", "infrastructure"]:
        state["next_action"] = "iac_architect"
    elif task_type in ["docker", "container", "dockerfile"]:
        state["next_action"] = "container_workflow"
    else:
        state["next_action"] = "end"

    record_supervisor_decision(state, "infra_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.infra_supervisor",
        {"task_type": task_type, "next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("infra_supervisor"),
    )
    logger.info("Infra supervisor routing to: %s", state["next_action"])
    return state


def iac_architect_node(state: AgentState) -> AgentState:
    """Execute infrastructure-as-code tasks.

    Delegates to iac-golden-architect subagent for Terraform operations.

    Args:
        state: Current agent state

    Returns:
        Updated state with IaC results
    """
    logger.info("Executing iac-golden-architect subagent")

    # Placeholder for actual IaC operations
    result = {
        "subagent": "iac-golden-architect",
        "action": "terraform_plan",
        "status": "success",
        "output": "Infrastructure plan generated successfully",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["iac"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "iac.result",
        result,
        access_context=AccessContext.for_agent("iac_architect"),
    )
    return state


def container_workflow_node(state: AgentState) -> AgentState:
    """Execute container-related tasks.

    Delegates to container-workflow subagent for Docker operations.

    Args:
        state: Current agent state

    Returns:
        Updated state with container results
    """
    logger.info("Executing container-workflow subagent")

    # Placeholder for actual container operations
    result = {
        "subagent": "container-workflow",
        "action": "dockerfile_review",
        "status": "success",
        "output": "Dockerfile validated and optimized",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["container"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "container.result",
        result,
        access_context=AccessContext.for_agent("container_workflow"),
    )
    return state


def team_accelerator_node(state: AgentState) -> AgentState:
    """Execute team acceleration tasks.

    Delegates to team-accelerator subagent for repository and pipeline setup.

    Args:
        state: Current agent state

    Returns:
        Updated state with team accelerator results
    """
    logger.info("Executing team-accelerator subagent")

    # Placeholder for actual team acceleration operations
    result = {
        "subagent": "team-accelerator",
        "action": "repository_creation",
        "status": "success",
        "output": "Repository and pipeline configured",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["team"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "agent",
        "team.result",
        result,
        access_context=AccessContext.for_agent("team_accelerator"),
    )
    return state


def general_orchestration_node(state: AgentState) -> AgentState:
    """Handle general orchestration tasks.

    Coordinates multiple subagents for complex workflows.

    Args:
        state: Current agent state

    Returns:
        Updated state with orchestration results
    """
    logger.info("Executing general orchestration")

    result = {
        "subagent": "orchestrator",
        "action": "multi_agent_coordination",
        "status": "success",
        "output": "Task coordinated across subagents",
    }

    state.setdefault("subagent_results", {})
    state["subagent_results"]["orchestration"] = result
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "orchestration.result",
        result,
        access_context=AccessContext.for_workflow("general_orchestration"),
    )
    return state


def _evaluate_subagent_result(result: Dict[str, Any]) -> Dict[str, Any]:
    """Evaluate a subagent result for quality, completeness, and risks."""
    status = result.get("status", "unknown")
    output = result.get("output", "")
    risks: List[str] = []
    quality = "high"
    completeness = "complete"

    if status != "success":
        quality = "low"
        completeness = "partial"
        risks.append("execution_failed")

    if not output:
        completeness = "partial"
        risks.append("missing_output")

    if isinstance(output, str) and "warning" in output.lower():
        risks.append("warnings_present")

    return {"quality": quality, "completeness": completeness, "risks": risks}


def _score_candidate(candidate: Dict[str, Any]) -> Dict[str, Any]:
    """Score a candidate result set based on evaluation heuristics."""
    score = 0
    assessments: Dict[str, Any] = {}

    for result_key, result in candidate["results"].items():
        outcome = _evaluate_subagent_result(result)
        assessments[result_key] = outcome
        if outcome["quality"] == "high":
            score += 2
        else:
            score -= 1
        if outcome["completeness"] == "complete":
            score += 1
        else:
            score -= 1
        score -= len(outcome["risks"])

    return {"score": score, "assessments": assessments}


def _build_candidate_variants(results: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Create multiple candidate variants from base subagent results."""
    baseline = copy.deepcopy(results)
    enriched = copy.deepcopy(results)
    risk_averse = copy.deepcopy(results)

    for result in enriched.values():
        output = result.get("output", "")
        if output:
            result["output"] = f"{output} (validated for completeness)"
        else:
            result["output"] = "No output provided; additional investigation recommended."

    for result in risk_averse.values():
        if result.get("status") != "success":
            result["status"] = "needs_review"
        output = result.get("output", "")
        if output and "warning" not in output.lower():
            result["output"] = f"{output} (risk review: no warnings detected)"

    return [
        {"name": "baseline", "results": baseline},
        {"name": "enriched", "results": enriched},
        {"name": "risk_averse", "results": risk_averse},
    ]


def _combine_candidate_results(candidates: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Combine candidate results into a single merged outcome."""
    combined: Dict[str, Any] = {}
    for candidate in candidates:
        for key, result in candidate["results"].items():
            existing = combined.get(key)
            if not existing:
                combined[key] = copy.deepcopy(result)
                continue
            existing_outputs = {existing.get("output", "")}
            existing_outputs.add(result.get("output", ""))
            combined_output = " | ".join(output for output in existing_outputs if output)
            existing["output"] = combined_output or existing.get("output", "")
            if existing.get("status") != result.get("status"):
                existing["status"] = "mixed"
    return combined


def _supervisor_for_result(result_key: str, result: Dict[str, Any]) -> str:
    """Return the supervisor name to re-route for a given result."""
    mapping = {
        "iac": "infra_supervisor",
        "container": "infra_supervisor",
        "team": "delivery_supervisor",
        "orchestration": "root_supervisor",
    }
    return mapping.get(result_key, "root_supervisor")


def reflection_node(state: AgentState) -> AgentState:
    """Evaluate subagent results and determine remediation or rerouting."""
    logger.info("Reflecting on subagent results for quality checks")
    results = state.get("subagent_results", {})
    reflection_outcomes: Dict[str, Any] = {}
    remediation_tasks: List[Dict[str, Any]] = []
    reroute_targets: List[str] = []

    for result_key, result in results.items():
        outcome = _evaluate_subagent_result(result)
        reflection_outcomes[result_key] = outcome
        if outcome["risks"] or outcome["quality"] != "high" or outcome["completeness"] != "complete":
            remediation_tasks.append(
                {
                    "subagent": result.get("subagent", result_key),
                    "issue": outcome,
                    "action": "review_and_retry",
                }
            )
            reroute_targets.append(_supervisor_for_result(result_key, result))
            state.setdefault("failure_history", [])
            state["failure_history"].append(
                {
                    "timestamp": _utc_timestamp(),
                    "result_key": result_key,
                    "subagent": result.get("subagent", result_key),
                    "issue": outcome,
                }
            )

    state["reflection_outcomes"] = reflection_outcomes
    if remediation_tasks:
        state.setdefault("remediation_tasks", [])
        state["remediation_tasks"].extend(remediation_tasks)
    context_signals = state.setdefault("context_signals", {})
    risk_tags = _aggregate_risk_tags(reflection_outcomes)
    context_signals.update(
        {
            "needs_retry": bool(remediation_tasks),
            "risk_tags": risk_tags,
            "recent_failure_count": len(state.get("failure_history", [])),
            "last_failure_subagents": [
                entry["subagent"] for entry in state.get("failure_history", [])[-3:]
            ],
        }
    )

    state["next_action"] = reroute_targets[0] if reroute_targets else "complete"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "reflection.outcomes",
        {"outcomes": reflection_outcomes, "remediation_tasks": remediation_tasks},
        access_context=AccessContext.for_workflow("reflection"),
    )
    memory_bus.set(
        "workflow",
        "reflection.context_signals",
        context_signals,
        access_context=AccessContext.for_workflow("reflection"),
    )
    logger.info("Reflection completed; next action: %s", state["next_action"])
    return state


def fork_candidates_node(state: AgentState) -> AgentState:
    """Fork state into candidate variants and checkpoint each branch."""
    logger.info("Forking state into candidate variants via checkpoints")
    results = state.get("subagent_results", {})
    candidate_results = _build_candidate_variants(results)
    fork_checkpoint_ids: List[str] = []

    for index, candidate in enumerate(candidate_results, start=1):
        checkpoint_id = str(uuid4())
        checkpoint = empty_checkpoint()
        checkpoint["channel_values"] = {"candidate": candidate}
        checkpoint = create_checkpoint(checkpoint, None, index, id=checkpoint_id)
        metadata = {
            "source": "state_fork",
            "candidate_name": candidate["name"],
            "candidate_index": index,
        }
        CHECKPOINTER.put({"configurable": {"checkpoint_id": checkpoint_id}}, checkpoint, metadata, {})
        fork_checkpoint_ids.append(checkpoint_id)

    state["candidate_results"] = candidate_results
    state["fork_checkpoint_ids"] = fork_checkpoint_ids
    state["next_action"] = "merge_candidates"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "forks.candidates",
        {"candidates": candidate_results, "checkpoint_ids": fork_checkpoint_ids},
        access_context=AccessContext.for_workflow("fork_candidates"),
    )
    return state


def merge_candidates_node(state: AgentState) -> AgentState:
    """Evaluate forked candidates and select or combine the best outcome."""
    logger.info("Merging candidate results after fork evaluation")
    candidate_results = state.get("candidate_results", [])
    if not candidate_results:
        state["next_action"] = "reflection"
        return state

    scored_candidates: List[Dict[str, Any]] = []
    for candidate in candidate_results:
        evaluation = _score_candidate(candidate)
        scored_candidates.append(
            {
                "name": candidate["name"],
                "results": candidate["results"],
                "score": evaluation["score"],
                "assessments": evaluation["assessments"],
            }
        )

    best_score = max(candidate["score"] for candidate in scored_candidates)
    top_candidates = [candidate for candidate in scored_candidates if candidate["score"] == best_score]
    if len(top_candidates) == 1:
        selected_results = top_candidates[0]["results"]
        selection_summary = {"selection": top_candidates[0]["name"], "score": best_score}
    else:
        selected_results = _combine_candidate_results(top_candidates)
        selection_summary = {
            "selection": "combined",
            "candidates": [candidate["name"] for candidate in top_candidates],
            "score": best_score,
        }

    state["subagent_results"] = selected_results
    state["merge_result"] = {
        "summary": selection_summary,
        "scored_candidates": scored_candidates,
    }
    state["next_action"] = "reflection"
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "merge.result",
        state["merge_result"],
        access_context=AccessContext.for_workflow("merge_candidates"),
    )
    return state


def delivery_supervisor_node(state: AgentState) -> AgentState:
    """Route delivery tasks to the delivery subagent.

    Args:
        state: Current agent state

    Returns:
        Updated state with next_action
    """
    state["next_action"] = "team_accelerator"
    record_supervisor_decision(state, "delivery_supervisor", state["next_action"])
    memory_bus = get_memory_bus(state)
    memory_bus.set(
        "workflow",
        "routing.delivery_supervisor",
        {"next_action": state["next_action"]},
        access_context=AccessContext.for_workflow("delivery_supervisor"),
    )
    logger.info("Delivery supervisor routing to: %s", state["next_action"])
    return state


def route_root_step(
    state: AgentState,
) -> Literal["infra_supervisor", "delivery_supervisor", "general_orchestration", "end"]:
    """Route to the next workflow step based on state."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_infra_step(
    state: AgentState,
) -> Literal["iac_architect", "container_workflow", "end"]:
    """Route within the infra subgraph."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_delivery_step(
    state: AgentState,
) -> Literal["team_accelerator", "end"]:
    """Route within the delivery subgraph."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_post_subgraph(
    state: AgentState,
) -> Literal["fork_candidates", "end"]:
    """Route after subgraph execution to forked candidate evaluation or end."""
    next_action = state.get("next_action", "end")
    if next_action == "reflection":
        return "fork_candidates"
    return "end"


def route_to_end(state: AgentState) -> Literal["end"]:
    """Route leaf nodes to the end state."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return "end"


def route_reflection_step(
    state: AgentState,
) -> Literal["infra_supervisor", "delivery_supervisor", "root_supervisor", "end"]:
    """Route from reflection to the appropriate supervisor or end."""
    next_action = state.get("next_action", "end")
    if next_action == "complete":
        return "end"
    return next_action  # type: ignore


def route_merge_step(
    state: AgentState,
) -> Literal["reflection", "end"]:
    """Route from merge to reflection or end."""
    next_action = state.get("next_action", "end")
    if next_action == "reflection":
        return "reflection"
    return "end"


def create_infra_subgraph() -> StateGraph:
    """Create the infra supervisor subgraph."""
    infra_graph = StateGraph(AgentState)

    infra_graph.add_node("infra_supervisor", infra_supervisor_node)
    infra_graph.add_node("iac_architect", iac_architect_node)
    infra_graph.add_node("container_workflow", container_workflow_node)

    infra_graph.set_entry_point("infra_supervisor")
    infra_graph.add_conditional_edges(
        "infra_supervisor",
        route_infra_step,
        {
            "iac_architect": "iac_architect",
            "container_workflow": "container_workflow",
            "end": END,
        },
    )
    infra_graph.add_conditional_edges("iac_architect", route_to_end, {"end": END})
    infra_graph.add_conditional_edges("container_workflow", route_to_end, {"end": END})

    return infra_graph.compile()


def create_delivery_subgraph() -> StateGraph:
    """Create the delivery supervisor subgraph."""
    delivery_graph = StateGraph(AgentState)

    delivery_graph.add_node("delivery_supervisor", delivery_supervisor_node)
    delivery_graph.add_node("team_accelerator", team_accelerator_node)

    delivery_graph.set_entry_point("delivery_supervisor")
    delivery_graph.add_conditional_edges(
        "delivery_supervisor",
        route_delivery_step,
        {"team_accelerator": "team_accelerator", "end": END},
    )
    delivery_graph.add_conditional_edges("team_accelerator", route_to_end, {"end": END})

    return delivery_graph.compile()


def create_agent_workflow() -> StateGraph:
    """Create the LangGraph workflow for the Deep Agent.

    Returns:
        Compiled workflow graph
    """
    workflow = StateGraph(AgentState)

    # Add nodes
    workflow.add_node("root_supervisor", root_supervisor_node)
    workflow.add_node("infra_supervisor", create_infra_subgraph())
    workflow.add_node("delivery_supervisor", create_delivery_subgraph())
    workflow.add_node("general_orchestration", general_orchestration_node)
    workflow.add_node("fork_candidates", fork_candidates_node)
    workflow.add_node("merge_candidates", merge_candidates_node)
    workflow.add_node("reflection", reflection_node)

    # Define edges
    workflow.set_entry_point("root_supervisor")

    workflow.add_conditional_edges(
        "root_supervisor",
        route_root_step,
        {
            "infra_supervisor": "infra_supervisor",
            "delivery_supervisor": "delivery_supervisor",
            "general_orchestration": "general_orchestration",
            "end": END,
        },
    )

    workflow.add_conditional_edges(
        "infra_supervisor",
        route_post_subgraph,
        {"fork_candidates": "fork_candidates", "end": END},
    )
    workflow.add_conditional_edges(
        "delivery_supervisor",
        route_post_subgraph,
        {"fork_candidates": "fork_candidates", "end": END},
    )
    workflow.add_conditional_edges(
        "general_orchestration",
        route_post_subgraph,
        {"fork_candidates": "fork_candidates", "end": END},
    )
    workflow.add_edge("fork_candidates", "merge_candidates")
    workflow.add_conditional_edges(
        "merge_candidates",
        route_merge_step,
        {"reflection": "reflection", "end": END},
    )
    workflow.add_conditional_edges(
        "reflection",
        route_reflection_step,
        {
            "infra_supervisor": "infra_supervisor",
            "delivery_supervisor": "delivery_supervisor",
            "root_supervisor": "root_supervisor",
            "end": END,
        },
    )

    return workflow.compile(checkpointer=CHECKPOINTER)
